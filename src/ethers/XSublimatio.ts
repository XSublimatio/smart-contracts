/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
    BaseContract,
    BigNumber,
    BigNumberish,
    BytesLike,
    CallOverrides,
    ContractTransaction,
    Overrides,
    PayableOverrides,
    PopulatedTransaction,
    Signer,
    utils,
} from 'ethers';
import { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import { Listener, Provider } from '@ethersproject/providers';
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from './common';

export interface XSublimatioInterface extends utils.Interface {
    contractName: 'XSublimatio';
    functions: {
        'DECOMPOSITION_TIME()': FunctionFragment;
        'PRICE_PER_TOKEN_MINT()': FunctionFragment;
        'PURCHASE_BATCH_SIZE()': FunctionFragment;
        'acceptOwnership()': FunctionFragment;
        'approve(address,uint256)': FunctionFragment;
        'availabilities()': FunctionFragment;
        'balanceOf(address)': FunctionFragment;
        'baseURI()': FunctionFragment;
        'brew(uint256[],uint256,address)': FunctionFragment;
        'brewingEnabled()': FunctionFragment;
        'burnDateFor(uint256)': FunctionFragment;
        'consumingEnabledFor(address)': FunctionFragment;
        'contractURI()': FunctionFragment;
        'decompose(uint256)': FunctionFragment;
        'drugAvailabilities()': FunctionFragment;
        'drugsAvailable()': FunctionFragment;
        'enableBrewing()': FunctionFragment;
        'enableConsumingFor(address)': FunctionFragment;
        'getApproved(uint256)': FunctionFragment;
        'getDrugAvailability(uint256)': FunctionFragment;
        'getMoleculeAvailability(uint256)': FunctionFragment;
        'getRecipe(uint256)': FunctionFragment;
        'isApprovedForAll(address,address)': FunctionFragment;
        'moleculeAvailabilities()': FunctionFragment;
        'moleculesAvailable()': FunctionFragment;
        'name()': FunctionFragment;
        'owner()': FunctionFragment;
        'ownerOf(uint256)': FunctionFragment;
        'pendingOwner()': FunctionFragment;
        'proposeOwnership(address)': FunctionFragment;
        'purchase(address,uint256)': FunctionFragment;
        'safeTransferFrom(address,address,uint256)': FunctionFragment;
        'setApprovalForAll(address,bool)': FunctionFragment;
        'setBaseURI(string)': FunctionFragment;
        'startDecomposition(uint256)': FunctionFragment;
        'supportsInterface(bytes4)': FunctionFragment;
        'symbol()': FunctionFragment;
        'tokenByIndex(uint256)': FunctionFragment;
        'tokenOfOwnerByIndex(address,uint256)': FunctionFragment;
        'tokenURI(uint256)': FunctionFragment;
        'tokensOfOwner(address)': FunctionFragment;
        'totalSupply()': FunctionFragment;
        'transferFrom(address,address,uint256)': FunctionFragment;
        'withdrawProceeds(uint256,address)': FunctionFragment;
    };

    encodeFunctionData(functionFragment: 'DECOMPOSITION_TIME', values?: undefined): string;
    encodeFunctionData(functionFragment: 'PRICE_PER_TOKEN_MINT', values?: undefined): string;
    encodeFunctionData(functionFragment: 'PURCHASE_BATCH_SIZE', values?: undefined): string;
    encodeFunctionData(functionFragment: 'acceptOwnership', values?: undefined): string;
    encodeFunctionData(functionFragment: 'approve', values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'availabilities', values?: undefined): string;
    encodeFunctionData(functionFragment: 'balanceOf', values: [string]): string;
    encodeFunctionData(functionFragment: 'baseURI', values?: undefined): string;
    encodeFunctionData(functionFragment: 'brew', values: [BigNumberish[], BigNumberish, string]): string;
    encodeFunctionData(functionFragment: 'brewingEnabled', values?: undefined): string;
    encodeFunctionData(functionFragment: 'burnDateFor', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'consumingEnabledFor', values: [string]): string;
    encodeFunctionData(functionFragment: 'contractURI', values?: undefined): string;
    encodeFunctionData(functionFragment: 'decompose', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'drugAvailabilities', values?: undefined): string;
    encodeFunctionData(functionFragment: 'drugsAvailable', values?: undefined): string;
    encodeFunctionData(functionFragment: 'enableBrewing', values?: undefined): string;
    encodeFunctionData(functionFragment: 'enableConsumingFor', values: [string]): string;
    encodeFunctionData(functionFragment: 'getApproved', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'getDrugAvailability', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'getMoleculeAvailability', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'getRecipe', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'isApprovedForAll', values: [string, string]): string;
    encodeFunctionData(functionFragment: 'moleculeAvailabilities', values?: undefined): string;
    encodeFunctionData(functionFragment: 'moleculesAvailable', values?: undefined): string;
    encodeFunctionData(functionFragment: 'name', values?: undefined): string;
    encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
    encodeFunctionData(functionFragment: 'ownerOf', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'pendingOwner', values?: undefined): string;
    encodeFunctionData(functionFragment: 'proposeOwnership', values: [string]): string;
    encodeFunctionData(functionFragment: 'purchase', values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'safeTransferFrom', values: [string, string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'setApprovalForAll', values: [string, boolean]): string;
    encodeFunctionData(functionFragment: 'setBaseURI', values: [string]): string;
    encodeFunctionData(functionFragment: 'startDecomposition', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'supportsInterface', values: [BytesLike]): string;
    encodeFunctionData(functionFragment: 'symbol', values?: undefined): string;
    encodeFunctionData(functionFragment: 'tokenByIndex', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'tokenOfOwnerByIndex', values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'tokenURI', values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: 'tokensOfOwner', values: [string]): string;
    encodeFunctionData(functionFragment: 'totalSupply', values?: undefined): string;
    encodeFunctionData(functionFragment: 'transferFrom', values: [string, string, BigNumberish]): string;
    encodeFunctionData(functionFragment: 'withdrawProceeds', values: [BigNumberish, string]): string;

    decodeFunctionResult(functionFragment: 'DECOMPOSITION_TIME', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'PRICE_PER_TOKEN_MINT', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'PURCHASE_BATCH_SIZE', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'acceptOwnership', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'approve', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'availabilities', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'baseURI', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'brew', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'brewingEnabled', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'burnDateFor', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'consumingEnabledFor', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'contractURI', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'decompose', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'drugAvailabilities', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'drugsAvailable', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'enableBrewing', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'enableConsumingFor', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'getApproved', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'getDrugAvailability', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'getMoleculeAvailability', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'getRecipe', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'isApprovedForAll', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'moleculeAvailabilities', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'moleculesAvailable', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'ownerOf', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'pendingOwner', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'proposeOwnership', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'purchase', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'safeTransferFrom', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'setApprovalForAll', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'setBaseURI', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'startDecomposition', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'supportsInterface', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'tokenByIndex', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'tokenOfOwnerByIndex', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'tokenURI', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'tokensOfOwner', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'totalSupply', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'transferFrom', data: BytesLike): Result;
    decodeFunctionResult(functionFragment: 'withdrawProceeds', data: BytesLike): Result;

    events: {
        'Approval(address,address,uint256)': EventFragment;
        'ApprovalForAll(address,address,bool)': EventFragment;
        'BaseURISet(string)': EventFragment;
        'BrewingEnabled()': EventFragment;
        'ConsumingEnabled(address)': EventFragment;
        'DecompositionStarted(address,uint256,uint256)': EventFragment;
        'OwnershipAccepted(address,address)': EventFragment;
        'OwnershipProposed(address,address)': EventFragment;
        'ProceedsWithdrawn(address,uint256)': EventFragment;
        'Transfer(address,address,uint256)': EventFragment;
    };

    getEvent(nameOrSignatureOrTopic: 'Approval'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'ApprovalForAll'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'BaseURISet'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'BrewingEnabled'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'ConsumingEnabled'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'DecompositionStarted'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'OwnershipAccepted'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'OwnershipProposed'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'ProceedsWithdrawn'): EventFragment;
    getEvent(nameOrSignatureOrTopic: 'Transfer'): EventFragment;
}

export type ApprovalEvent = TypedEvent<[string, string, BigNumber], { owner: string; approved: string; tokenId: BigNumber }>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export type ApprovalForAllEvent = TypedEvent<[string, string, boolean], { owner: string; operator: string; approved: boolean }>;

export type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;

export type BaseURISetEvent = TypedEvent<[string], { baseURI: string }>;

export type BaseURISetEventFilter = TypedEventFilter<BaseURISetEvent>;

export type BrewingEnabledEvent = TypedEvent<[], {}>;

export type BrewingEnabledEventFilter = TypedEventFilter<BrewingEnabledEvent>;

export type ConsumingEnabledEvent = TypedEvent<[string], { consumer: string }>;

export type ConsumingEnabledEventFilter = TypedEventFilter<ConsumingEnabledEvent>;

export type DecompositionStartedEvent = TypedEvent<
    [string, BigNumber, BigNumber],
    { owner: string; tokenId: BigNumber; burnDate: BigNumber }
>;

export type DecompositionStartedEventFilter = TypedEventFilter<DecompositionStartedEvent>;

export type OwnershipAcceptedEvent = TypedEvent<[string, string], { previousOwner: string; owner: string }>;

export type OwnershipAcceptedEventFilter = TypedEventFilter<OwnershipAcceptedEvent>;

export type OwnershipProposedEvent = TypedEvent<[string, string], { owner: string; pendingOwner: string }>;

export type OwnershipProposedEventFilter = TypedEventFilter<OwnershipProposedEvent>;

export type ProceedsWithdrawnEvent = TypedEvent<[string, BigNumber], { destination: string; amount: BigNumber }>;

export type ProceedsWithdrawnEventFilter = TypedEventFilter<ProceedsWithdrawnEvent>;

export type TransferEvent = TypedEvent<[string, string, BigNumber], { from: string; to: string; tokenId: BigNumber }>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface XSublimatio extends BaseContract {
    contractName: 'XSublimatio';
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;

    interface: XSublimatioInterface;

    queryFilter<TEvent extends TypedEvent>(
        event: TypedEventFilter<TEvent>,
        fromBlockOrBlockhash?: string | number | undefined,
        toBlock?: string | number | undefined
    ): Promise<Array<TEvent>>;

    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;

    functions: {
        DECOMPOSITION_TIME(overrides?: CallOverrides): Promise<[BigNumber]>;

        PRICE_PER_TOKEN_MINT(overrides?: CallOverrides): Promise<[BigNumber]>;

        PURCHASE_BATCH_SIZE(overrides?: CallOverrides): Promise<[BigNumber]>;

        acceptOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

        approve(
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        availabilities(overrides?: CallOverrides): Promise<
            [BigNumber[], BigNumber[]] & {
                moleculesAvailabilities_: BigNumber[];
                drugAvailabilities_: BigNumber[];
            }
        >;

        balanceOf(owner: string, overrides?: CallOverrides): Promise<[BigNumber]>;

        baseURI(overrides?: CallOverrides): Promise<[string]>;

        brew(
            tokenIds_: BigNumberish[],
            drugType_: BigNumberish,
            destination_: string,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        brewingEnabled(overrides?: CallOverrides): Promise<[boolean]>;

        burnDateFor(arg0: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

        consumingEnabledFor(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;

        contractURI(overrides?: CallOverrides): Promise<[string] & { contractURI_: string }>;

        decompose(tokenId_: BigNumberish, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

        drugAvailabilities(overrides?: CallOverrides): Promise<[BigNumber[]] & { availabilities_: BigNumber[] }>;

        drugsAvailable(overrides?: CallOverrides): Promise<[BigNumber] & { drugsAvailable_: BigNumber }>;

        enableBrewing(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

        enableConsumingFor(consumer_: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

        getApproved(tokenId: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

        getDrugAvailability(drugType_: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber] & { availability_: BigNumber }>;

        getMoleculeAvailability(
            moleculeType_: BigNumberish,
            overrides?: CallOverrides
        ): Promise<[BigNumber] & { availability_: BigNumber }>;

        getRecipe(drugType_: BigNumberish, overrides?: CallOverrides): Promise<[number[]] & { recipe_: number[] }>;

        isApprovedForAll(owner: string, operator: string, overrides?: CallOverrides): Promise<[boolean]>;

        moleculeAvailabilities(overrides?: CallOverrides): Promise<[BigNumber[]] & { availabilities_: BigNumber[] }>;

        moleculesAvailable(overrides?: CallOverrides): Promise<[BigNumber] & { moleculesAvailable_: BigNumber }>;

        name(overrides?: CallOverrides): Promise<[string]>;

        owner(overrides?: CallOverrides): Promise<[string]>;

        ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

        pendingOwner(overrides?: CallOverrides): Promise<[string]>;

        proposeOwnership(newOwner_: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

        purchase(
            destination_: string,
            minQuantity_: BigNumberish,
            overrides?: PayableOverrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        'safeTransferFrom(address,address,uint256)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        'safeTransferFrom(address,address,uint256,bytes)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            _data: BytesLike,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        setApprovalForAll(
            operator: string,
            approved: boolean,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        setBaseURI(baseURI_: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

        startDecomposition(
            tokenId_: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<[boolean]>;

        symbol(overrides?: CallOverrides): Promise<[string]>;

        tokenByIndex(index: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

        tokenOfOwnerByIndex(owner: string, index: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

        tokenURI(tokenId_: BigNumberish, overrides?: CallOverrides): Promise<[string] & { tokenURI_: string }>;

        tokensOfOwner(owner_: string, overrides?: CallOverrides): Promise<[BigNumber[]] & { tokenIds_: BigNumber[] }>;

        totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

        transferFrom(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;

        withdrawProceeds(
            amount_: BigNumberish,
            destination_: string,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<ContractTransaction>;
    };

    DECOMPOSITION_TIME(overrides?: CallOverrides): Promise<BigNumber>;

    PRICE_PER_TOKEN_MINT(overrides?: CallOverrides): Promise<BigNumber>;

    PURCHASE_BATCH_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

    acceptOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    approve(to: string, tokenId: BigNumberish, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    availabilities(overrides?: CallOverrides): Promise<
        [BigNumber[], BigNumber[]] & {
            moleculesAvailabilities_: BigNumber[];
            drugAvailabilities_: BigNumber[];
        }
    >;

    balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;

    baseURI(overrides?: CallOverrides): Promise<string>;

    brew(
        tokenIds_: BigNumberish[],
        drugType_: BigNumberish,
        destination_: string,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    brewingEnabled(overrides?: CallOverrides): Promise<boolean>;

    burnDateFor(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    consumingEnabledFor(arg0: string, overrides?: CallOverrides): Promise<boolean>;

    contractURI(overrides?: CallOverrides): Promise<string>;

    decompose(tokenId_: BigNumberish, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    drugAvailabilities(overrides?: CallOverrides): Promise<BigNumber[]>;

    drugsAvailable(overrides?: CallOverrides): Promise<BigNumber>;

    enableBrewing(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    enableConsumingFor(consumer_: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    getApproved(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

    getDrugAvailability(drugType_: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    getMoleculeAvailability(moleculeType_: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    getRecipe(drugType_: BigNumberish, overrides?: CallOverrides): Promise<number[]>;

    isApprovedForAll(owner: string, operator: string, overrides?: CallOverrides): Promise<boolean>;

    moleculeAvailabilities(overrides?: CallOverrides): Promise<BigNumber[]>;

    moleculesAvailable(overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

    pendingOwner(overrides?: CallOverrides): Promise<string>;

    proposeOwnership(newOwner_: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    purchase(
        destination_: string,
        minQuantity_: BigNumberish,
        overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'safeTransferFrom(address,address,uint256)'(
        from: string,
        to: string,
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'safeTransferFrom(address,address,uint256,bytes)'(
        from: string,
        to: string,
        tokenId: BigNumberish,
        _data: BytesLike,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setApprovalForAll(
        operator: string,
        approved: boolean,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setBaseURI(baseURI_: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    startDecomposition(tokenId_: BigNumberish, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;

    symbol(overrides?: CallOverrides): Promise<string>;

    tokenByIndex(index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    tokenOfOwnerByIndex(owner: string, index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    tokenURI(tokenId_: BigNumberish, overrides?: CallOverrides): Promise<string>;

    tokensOfOwner(owner_: string, overrides?: CallOverrides): Promise<BigNumber[]>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transferFrom(
        from: string,
        to: string,
        tokenId: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    withdrawProceeds(
        amount_: BigNumberish,
        destination_: string,
        overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    callStatic: {
        DECOMPOSITION_TIME(overrides?: CallOverrides): Promise<BigNumber>;

        PRICE_PER_TOKEN_MINT(overrides?: CallOverrides): Promise<BigNumber>;

        PURCHASE_BATCH_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

        acceptOwnership(overrides?: CallOverrides): Promise<void>;

        approve(to: string, tokenId: BigNumberish, overrides?: CallOverrides): Promise<void>;

        availabilities(overrides?: CallOverrides): Promise<
            [BigNumber[], BigNumber[]] & {
                moleculesAvailabilities_: BigNumber[];
                drugAvailabilities_: BigNumber[];
            }
        >;

        balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;

        baseURI(overrides?: CallOverrides): Promise<string>;

        brew(tokenIds_: BigNumberish[], drugType_: BigNumberish, destination_: string, overrides?: CallOverrides): Promise<BigNumber>;

        brewingEnabled(overrides?: CallOverrides): Promise<boolean>;

        burnDateFor(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        consumingEnabledFor(arg0: string, overrides?: CallOverrides): Promise<boolean>;

        contractURI(overrides?: CallOverrides): Promise<string>;

        decompose(tokenId_: BigNumberish, overrides?: CallOverrides): Promise<void>;

        drugAvailabilities(overrides?: CallOverrides): Promise<BigNumber[]>;

        drugsAvailable(overrides?: CallOverrides): Promise<BigNumber>;

        enableBrewing(overrides?: CallOverrides): Promise<void>;

        enableConsumingFor(consumer_: string, overrides?: CallOverrides): Promise<void>;

        getApproved(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

        getDrugAvailability(drugType_: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        getMoleculeAvailability(moleculeType_: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        getRecipe(drugType_: BigNumberish, overrides?: CallOverrides): Promise<number[]>;

        isApprovedForAll(owner: string, operator: string, overrides?: CallOverrides): Promise<boolean>;

        moleculeAvailabilities(overrides?: CallOverrides): Promise<BigNumber[]>;

        moleculesAvailable(overrides?: CallOverrides): Promise<BigNumber>;

        name(overrides?: CallOverrides): Promise<string>;

        owner(overrides?: CallOverrides): Promise<string>;

        ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

        pendingOwner(overrides?: CallOverrides): Promise<string>;

        proposeOwnership(newOwner_: string, overrides?: CallOverrides): Promise<void>;

        purchase(destination_: string, minQuantity_: BigNumberish, overrides?: CallOverrides): Promise<BigNumber[]>;

        'safeTransferFrom(address,address,uint256)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: CallOverrides
        ): Promise<void>;

        'safeTransferFrom(address,address,uint256,bytes)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            _data: BytesLike,
            overrides?: CallOverrides
        ): Promise<void>;

        setApprovalForAll(operator: string, approved: boolean, overrides?: CallOverrides): Promise<void>;

        setBaseURI(baseURI_: string, overrides?: CallOverrides): Promise<void>;

        startDecomposition(tokenId_: BigNumberish, overrides?: CallOverrides): Promise<void>;

        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;

        symbol(overrides?: CallOverrides): Promise<string>;

        tokenByIndex(index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        tokenOfOwnerByIndex(owner: string, index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        tokenURI(tokenId_: BigNumberish, overrides?: CallOverrides): Promise<string>;

        tokensOfOwner(owner_: string, overrides?: CallOverrides): Promise<BigNumber[]>;

        totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

        transferFrom(from: string, to: string, tokenId: BigNumberish, overrides?: CallOverrides): Promise<void>;

        withdrawProceeds(amount_: BigNumberish, destination_: string, overrides?: CallOverrides): Promise<void>;
    };

    filters: {
        'Approval(address,address,uint256)'(
            owner?: string | null,
            approved?: string | null,
            tokenId?: BigNumberish | null
        ): ApprovalEventFilter;
        Approval(owner?: string | null, approved?: string | null, tokenId?: BigNumberish | null): ApprovalEventFilter;

        'ApprovalForAll(address,address,bool)'(owner?: string | null, operator?: string | null, approved?: null): ApprovalForAllEventFilter;
        ApprovalForAll(owner?: string | null, operator?: string | null, approved?: null): ApprovalForAllEventFilter;

        'BaseURISet(string)'(baseURI?: null): BaseURISetEventFilter;
        BaseURISet(baseURI?: null): BaseURISetEventFilter;

        'BrewingEnabled()'(): BrewingEnabledEventFilter;
        BrewingEnabled(): BrewingEnabledEventFilter;

        'ConsumingEnabled(address)'(consumer?: null): ConsumingEnabledEventFilter;
        ConsumingEnabled(consumer?: null): ConsumingEnabledEventFilter;

        'DecompositionStarted(address,uint256,uint256)'(
            owner?: string | null,
            tokenId?: BigNumberish | null,
            burnDate?: null
        ): DecompositionStartedEventFilter;
        DecompositionStarted(owner?: string | null, tokenId?: BigNumberish | null, burnDate?: null): DecompositionStartedEventFilter;

        'OwnershipAccepted(address,address)'(previousOwner?: string | null, owner?: string | null): OwnershipAcceptedEventFilter;
        OwnershipAccepted(previousOwner?: string | null, owner?: string | null): OwnershipAcceptedEventFilter;

        'OwnershipProposed(address,address)'(owner?: string | null, pendingOwner?: string | null): OwnershipProposedEventFilter;
        OwnershipProposed(owner?: string | null, pendingOwner?: string | null): OwnershipProposedEventFilter;

        'ProceedsWithdrawn(address,uint256)'(destination?: string | null, amount?: null): ProceedsWithdrawnEventFilter;
        ProceedsWithdrawn(destination?: string | null, amount?: null): ProceedsWithdrawnEventFilter;

        'Transfer(address,address,uint256)'(from?: string | null, to?: string | null, tokenId?: BigNumberish | null): TransferEventFilter;
        Transfer(from?: string | null, to?: string | null, tokenId?: BigNumberish | null): TransferEventFilter;
    };

    estimateGas: {
        DECOMPOSITION_TIME(overrides?: CallOverrides): Promise<BigNumber>;

        PRICE_PER_TOKEN_MINT(overrides?: CallOverrides): Promise<BigNumber>;

        PURCHASE_BATCH_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

        acceptOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

        approve(to: string, tokenId: BigNumberish, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

        availabilities(overrides?: CallOverrides): Promise<BigNumber>;

        balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;

        baseURI(overrides?: CallOverrides): Promise<BigNumber>;

        brew(
            tokenIds_: BigNumberish[],
            drugType_: BigNumberish,
            destination_: string,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        brewingEnabled(overrides?: CallOverrides): Promise<BigNumber>;

        burnDateFor(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        consumingEnabledFor(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

        contractURI(overrides?: CallOverrides): Promise<BigNumber>;

        decompose(tokenId_: BigNumberish, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

        drugAvailabilities(overrides?: CallOverrides): Promise<BigNumber>;

        drugsAvailable(overrides?: CallOverrides): Promise<BigNumber>;

        enableBrewing(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

        enableConsumingFor(consumer_: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

        getApproved(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        getDrugAvailability(drugType_: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        getMoleculeAvailability(moleculeType_: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        getRecipe(drugType_: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        isApprovedForAll(owner: string, operator: string, overrides?: CallOverrides): Promise<BigNumber>;

        moleculeAvailabilities(overrides?: CallOverrides): Promise<BigNumber>;

        moleculesAvailable(overrides?: CallOverrides): Promise<BigNumber>;

        name(overrides?: CallOverrides): Promise<BigNumber>;

        owner(overrides?: CallOverrides): Promise<BigNumber>;

        ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        pendingOwner(overrides?: CallOverrides): Promise<BigNumber>;

        proposeOwnership(newOwner_: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

        purchase(
            destination_: string,
            minQuantity_: BigNumberish,
            overrides?: PayableOverrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        'safeTransferFrom(address,address,uint256)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        'safeTransferFrom(address,address,uint256,bytes)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            _data: BytesLike,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        setApprovalForAll(
            operator: string,
            approved: boolean,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        setBaseURI(baseURI_: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

        startDecomposition(tokenId_: BigNumberish, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

        symbol(overrides?: CallOverrides): Promise<BigNumber>;

        tokenByIndex(index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        tokenOfOwnerByIndex(owner: string, index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        tokenURI(tokenId_: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

        tokensOfOwner(owner_: string, overrides?: CallOverrides): Promise<BigNumber>;

        totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

        transferFrom(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;

        withdrawProceeds(
            amount_: BigNumberish,
            destination_: string,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<BigNumber>;
    };

    populateTransaction: {
        DECOMPOSITION_TIME(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        PRICE_PER_TOKEN_MINT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        PURCHASE_BATCH_SIZE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        acceptOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

        approve(
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        availabilities(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        balanceOf(owner: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        baseURI(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        brew(
            tokenIds_: BigNumberish[],
            drugType_: BigNumberish,
            destination_: string,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        brewingEnabled(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        burnDateFor(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        consumingEnabledFor(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        contractURI(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        decompose(tokenId_: BigNumberish, overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

        drugAvailabilities(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        drugsAvailable(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        enableBrewing(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

        enableConsumingFor(consumer_: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

        getApproved(tokenId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        getDrugAvailability(drugType_: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        getMoleculeAvailability(moleculeType_: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        getRecipe(drugType_: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        isApprovedForAll(owner: string, operator: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        moleculeAvailabilities(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        moleculesAvailable(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        pendingOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        proposeOwnership(newOwner_: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

        purchase(
            destination_: string,
            minQuantity_: BigNumberish,
            overrides?: PayableOverrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        'safeTransferFrom(address,address,uint256)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        'safeTransferFrom(address,address,uint256,bytes)'(
            from: string,
            to: string,
            tokenId: BigNumberish,
            _data: BytesLike,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        setApprovalForAll(
            operator: string,
            approved: boolean,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        setBaseURI(baseURI_: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

        startDecomposition(
            tokenId_: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        tokenByIndex(index: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        tokenOfOwnerByIndex(owner: string, index: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        tokenURI(tokenId_: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        tokensOfOwner(owner_: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        transferFrom(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;

        withdrawProceeds(
            amount_: BigNumberish,
            destination_: string,
            overrides?: Overrides & { from?: string | Promise<string> }
        ): Promise<PopulatedTransaction>;
    };
}
